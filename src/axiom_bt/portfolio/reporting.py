"""
Optional portfolio reporting - generates additional artifacts when enabled.

Only active when AXIOM_BT_PORTFOLIO_REPORT=1 environment variable is set.
"""

import os
import json
from pathlib import Path
from typing import Optional
import pandas as pd

from axiom_bt.portfolio.ledger import PortfolioLedger


def should_generate_report() -> bool:
    """Check if portfolio reporting is enabled via environment variable."""
    return os.getenv("AXIOM_BT_PORTFOLIO_REPORT") == "1"


def generate_portfolio_artifacts(
    ledger: PortfolioLedger,
    run_dir: Path,
    trades_df: Optional[pd.DataFrame] = None
) -> list[str]:
    """
    Generate optional portfolio reporting artifacts.
    
    Only generates files if AXIOM_BT_PORTFOLIO_REPORT=1.
    
    Args:
        ledger: PortfolioLedger instance
        run_dir: Path to run directory
        trades_df: Optional trades DataFrame for additional stats
    """
    if not should_generate_report():
        return []  # Silently skip if flag not set
    
    generated_files = []
    
    # Get summary stats
    summary = ledger.summary()
    
    # 1) portfolio_ledger.csv
    ledger_df = ledger.to_frame()
    ledger_path = run_dir / "portfolio_ledger.csv"
    ledger_df.to_csv(ledger_path, index=False)
    generated_files.append("portfolio_ledger.csv")
    
    # 2) portfolio_summary.json
    summary_json = {
        **summary,
        "max_drawdown": _calculate_max_drawdown(ledger_df),
        "num_entries": len(ledger.entries)
    }
    
    # Add trade-specific stats if available
    if trades_df is not None and not trades_df.empty:
        summary_json["trades"] = {
            "count": len(trades_df),
            "wins": int((trades_df["pnl"] > 0).sum()),
            "losses": int((trades_df["pnl"] < 0).sum()),
            "win_rate": float((trades_df["pnl"] > 0).mean()),
        }
        
        # Breakdown by exit reason if available
        if "reason" in trades_df.columns:
            reason_counts = trades_df["reason"].value_counts().to_dict()
            summary_json["exit_reasons"] = {k: int(v) for k, v in reason_counts.items()}
    
    summary_path = run_dir / "portfolio_summary.json"
    with open(summary_path, 'w') as f:
        json.dump(summary_json, f, indent=2)
    generated_files.append("portfolio_summary.json")
    
    # 3) portfolio_report.md (human readable)
    report_md = _generate_markdown_report(summary_json, ledger)
    report_path = run_dir / "portfolio_report.md"
    with open(report_path, 'w') as f:
        f.write(report_md)
    generated_files.append("portfolio_report.md")
    
    return generated_files
    generated_files.append("portfolio_report.md")
    generated_files.append("portfolio_report.md")
    
    return generated_files


def _calculate_max_drawdown(ledger_df: pd.DataFrame) -> float:
    """Calculate maximum drawdown from equity curve."""
    if len(ledger_df) <= 1:
        return 0.0
    
    equity = ledger_df["equity_after"]
    peak = equity.expanding().max()
    drawdown = (equity - peak) / peak
    return float(drawdown.min() * 100)  # Return as percentage


def _generate_markdown_report(summary: dict, ledger: PortfolioLedger) -> str:
    """Generate human-readable markdown report."""
    report = f"""# Portfolio Ledger Report

## Summary

| Metric | Value |
|:-------|:------|
| **Initial Cash** | ${summary['initial_cash_usd']:.2f} |
| **Final Cash** | ${summary['final_cash_usd']:.2f} |
| **Total PnL** | ${summary['total_pnl_net_usd']:.2f} ({summary['total_pnl_net_usd']/summary['initial_cash_usd']*100:.2f}%) |
| **Peak Equity** | ${summary['peak_equity_usd']:.2f} |
| **Max Drawdown** | {summary.get('max_drawdown', 0):.2f}% |

## Costs

| Type | Amount |
|:-----|:-------|
| **Total Fees** | ${summary['total_fees_usd']:.2f} |
| **Total Slippage** | ${summary['total_slippage_usd']:.2f} |
| **Combined Costs** | ${summary['total_fees_usd'] + summary['total_slippage_usd']:.2f} |

## Activity

- **Events**: {summary['num_events']} (excl. START)
- **Ledger Entries**: {summary.get('num_entries', 0)}

"""
    
    # Add trade stats if available
    if "trades" in summary:
        trades = summary["trades"]
        report += f"""## Trade Statistics

- **Total Trades**: {trades['count']}
- **Wins**: {trades['wins']} ({trades['win_rate']*100:.1f}%)
- **Losses**: {trades['losses']}

"""
    
    # Add exit reason breakdown if available
    if "exit_reasons" in summary:
        report += "### Exit Reasons\n\n"
        for reason, count in summary["exit_reasons"].items():
            report += f"- **{reason}**: {count}\n"
        report += "\n"
    
    report += """---

*Report generated by PortfolioLedger (AXIOM_BT_PORTFOLIO_REPORT=1)*
"""
    
    return report
    return generated_files


def _cli_main():
    """
    CLI entry point for standalone portfolio reporting.
    
    Usage:
        PYTHONPATH=$(pwd)/src python -m axiom_bt.portfolio.reporting --run-dir <path>
    """
    import argparse
    import sys
    
    parser = argparse.ArgumentParser(
        description="Generate portfolio reporting artifacts from trades.csv",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate report for existing run
  python -m axiom_bt.portfolio.reporting --run-dir artifacts/backtests/260105_120000_AAPL
  
  # Specify output directory
  python -m axiom_bt.portfolio.reporting --run-dir <RUN_DIR> --out-dir ./reports
  
  # Override initial cash
  python -m axiom_bt.portfolio.reporting --run-dir <RUN_DIR> --initial-cash 50000
        """
    )
    
    parser.add_argument(
        "--run-dir",
        type=Path,
        required=True,
        help="Path to backtest run directory (contains trades.csv)"
    )
    parser.add_argument(
        "--out-dir",
        type=Path,
        default=None,
        help="Output directory (default: same as run-dir)"
    )
    parser.add_argument(
        "--initial-cash",
        type=float,
        default=None,
        help="Initial cash (default: auto-detect from run_meta.json or 10000)"
    )
    parser.add_argument(
        "--start-ts",
        type=str,
        default=None,
        help="Start timestamp ISO format (default: auto-detect from trades)"
    )
    
    args = parser.parse_args()
    
    run_dir = args.run_dir.resolve()
    out_dir = args.out_dir.resolve() if args.out_dir else run_dir
    
    # Validate run_dir exists
    if not run_dir.exists():
        print(f"Error: run_dir does not exist: {run_dir}", file=sys.stderr)
        sys.exit(1)
    
    # Find trades.csv
    trades_path = run_dir / "trades.csv"
    if not trades_path.exists():
        print(f"Error: trades.csv not found in {run_dir}", file=sys.stderr)
        sys.exit(1)
    
    # Load trades
    try:
        trades_df = pd.read_csv(trades_path)
    except Exception as e:
        print(f"Error loading trades.csv: {e}", file=sys.stderr)
        sys.exit(1)
    
    # Determine initial_cash
    initial_cash = args.initial_cash
    if initial_cash is None:
        # Try to read from run_meta.json or run_manifest.json
        for meta_file in ["run_manifest.json", "run_meta.json"]:
            meta_path = run_dir / meta_file
            if meta_path.exists():
                try:
                    with open(meta_path) as f:
                        meta = json.load(f)
                        # Try various paths where initial_cash might be
                        initial_cash = (
                            meta.get("params", {}).get("initial_cash") or
                            meta.get("data", {}).get("initial_cash") or
                            None
                        )
                        if initial_cash:
                            break
                except:
                    pass
        
        # Final fallback
        if initial_cash is None:
            initial_cash = 10000.0
            print(f"Warning: Using default initial_cash=10000", file=sys.stderr)
    
    # Parse start_ts if provided
    start_ts = None
    if args.start_ts:
        start_ts = pd.Timestamp(args.start_ts)
    
    # Create ledger via replay
    print(f"Replaying {len(trades_df)} trades...")
    ledger = PortfolioLedger.replay_from_trades(
        trades_df,
        initial_cash=initial_cash,
        start_ts=start_ts
    )
    
    # Generate artifacts (force generation regardless of env var)
    print(f"Generating portfolio artifacts to {out_dir}...")
    
    # Temporarily force reporting ON
    os.environ["AXIOM_BT_PORTFOLIO_REPORT"] = "1"
    try:
        generated_files = generate_portfolio_artifacts(
            ledger=ledger,
            run_dir=out_dir,
            trades_df=trades_df
        )
    finally:
        # Restore original env (if it wasn't set)
        if "AXIOM_BT_PORTFOLIO_REPORT" in os.environ:
            del os.environ["AXIOM_BT_PORTFOLIO_REPORT"]
    
    # Report success
    print(f"\nâœ… Generated {len(generated_files)} artifacts:")
    for filename in generated_files:
        filepath = out_dir / filename
        size = filepath.stat().st_size
        print(f"  - {filename} ({size} bytes)")
    
    print(f"\nOutput directory: {out_dir}")


if __name__ == "__main__":
    _cli_main()
