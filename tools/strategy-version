#!/usr/bin/env python3
"""
Strategy Version Management CLI

Manage versioned strategy configurations, backtest runs, and deployments.

Usage:
    strategy-version list inside_bar
    strategy-version show inside_bar v1.00
    strategy-version create inside_bar --from v1.00
    strategy-version diff inside_bar v1.00 v1.01
    strategy-version deploy inside_bar v1.00 --to pre-papertrading
"""
import argparse
import sqlite3
import yaml
import json
import hashlib
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional
import sys


class StrategyVersionManager:
    def __init__(self, strategy_name: str, base_dir: Path = None):
        self.strategy_name = strategy_name
        self.base_dir = base_dir or Path(__file__).parent.parent
        self.strategy_dir = self.base_dir / "src" / "strategies" / strategy_name
        self.versions_dir = self.strategy_dir / "versions"
        self.runs_dir = self.strategy_dir / "runs"
        self.results_dir = self.strategy_dir / "results"
        self.db_path = self.strategy_dir / "registry.db"
        
        if not self.db_path.exists():
            print(f"‚ùå Registry not found: {self.db_path}")
            print(f"Run: python tools/init_registry.py")
            sys.exit(1)
    
    def list_versions(self):
        """List all versions with summary."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT 
                v.version,
                v.created_at,
                v.status,
                v.lab_stage,
                COUNT(DISTINCT br.run_id) as run_count
            FROM versions v
            LEFT JOIN backtest_runs br ON v.version = br.version
            GROUP BY v.version
            ORDER BY v.created_at DESC
        """)
        
        versions = cursor.fetchall()
        conn.close()
        
        if not versions:
            print("No versions found")
            return
        
        print(f"\n{'Version':<10} {'Created':<12} {'Status':<15} {'Lab Stage':<20} {'Runs':<6}")
        print("-" * 70)
        
        for version, created_at, status, lab_stage, run_count in versions:
            created = datetime.fromisoformat(created_at).strftime("%Y-%m-%d")
            lab = lab_stage or "-"
            print(f"v{version:<9} {created:<12} {status:<15} {lab:<20} {run_count:<6}")
    
    def show_version(self, version: str):
        """Show detailed version information."""
        version_file = self.versions_dir / f"v{version}.yaml"
        
        if not version_file.exists():
            print(f"‚ùå Version v{version} not found")
            return
        
        with open(version_file, 'r') as f:
            config = yaml.safe_load(f)
        
        print(f"\n‚ïê‚ïê‚ïê Version v{version} ‚ïê‚ïê‚ïê\n")
        
        # Metadata
        meta = config.get('version_meta', {})
        print(f"Created: {meta.get('created_at', 'Unknown')}")
        print(f"Created by: {meta.get('created_by', 'Unknown')}")
        print(f"Status: {meta.get('status', 'Unknown')}")
        if meta.get('parent_version'):
            print(f"Parent: v{meta['parent_version']}")
        print(f"Config Hash: {meta.get('config_hash', 'Unknown')}")
        
        # Parameters
        print(f"\nüìã Parameters:")
        params = config.get('parameters', {})
        for key, value in params.items():
            print(f"  {key}: {value}")
        
        # Changes
        if 'changes_from_parent' in config:
            print(f"\nüîß Changes:")
            for change in config['changes_from_parent']:
                if isinstance(change, dict):
                    print(f"  - {change.get('note', change.get('reason', str(change)))}")
                else:
                    print(f"  - {change}")
        
        # Notes
        if 'notes' in config:
            print(f"\nüìù Notes:")
            print(f"  {config['notes'].strip()}")
        
        # Backtest runs
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT run_id, started_at, status, total_trades, win_rate, sharpe_ratio
            FROM backtest_runs
            WHERE version = ?
            ORDER BY started_at DESC
            LIMIT 5
        """, (version,))
        runs = cursor.fetchall()
        conn.close()
        
        if runs:
            print(f"\nüìä Recent Backtest Runs:")
            for run_id, started, status, trades, win_rate, sharpe in runs:
                started_fmt = datetime.fromisoformat(started).strftime("%Y-%m-%d %H:%M")
                wr = f"{win_rate*100:.1f}%" if win_rate else "N/A"
                sh = f"{sharpe:.2f}" if sharpe else "N/A"
                print(f"  {run_id}: {started_fmt} | {status} | Trades: {trades or 0} | WR: {wr} | Sharpe: {sh}")
    
    def create_version(
        self,
        from_version: str,
        new_version: Optional[str] = None,
        params_to_change: Optional[Dict] = None,
        notes: str = ""
    ):
        """Create new version from existing one."""
        # Load parent version
        parent_file = self.versions_dir / f"v{from_version}.yaml"
        if not parent_file.exists():
            print(f"‚ùå Parent version v{from_version} not found")
            return
        
        with open(parent_file, 'r') as f:
            parent_config = yaml.safe_load(f)
        
        # Suggest next version if not provided
        if not new_version:
            new_version = self._suggest_next_version(from_version)
            response = input(f"Create version v{new_version}? [Y/n/custom]: ").strip().lower()
            if response == 'n':
                return
            elif response not in ['', 'y']:
                new_version = input("Enter version number (e.g., 2.00): ").strip()
        
        # Create new config
        new_config = parent_config.copy()
        new_config['version_meta'] = {
            'version': new_version,
            'created_at': datetime.now().isoformat(),
            'created_by': 'mirko',
            'parent_version': from_version,
            'change_type': 'increment' if self._is_minor_update(from_version, new_version) else 'major',
            'config_hash': '',  # Will be calculated
            'status': 'draft'
        }
        
        # Apply parameter changes
        changes = []
        if params_to_change:
            for param, new_value in params_to_change.items():
                old_value = new_config['parameters'].get(param)
                new_config['parameters'][param] = new_value
                changes.append({
                    'param': param,
                    'old': old_value,
                    'new': new_value
                })
        
        new_config['changes_from_parent'] = changes
        new_config['notes'] = notes or f"Incremented from v{from_version}"
        
        # Save new version
        new_file = self.versions_dir / f"v{new_version}.yaml"
        with open(new_file, 'w') as f:
            yaml.dump(new_config, f, default_flow_style=False, sort_keys=False)
        
        # Calculate hash
        config_hash = self._calculate_hash(new_file)
        new_config['version_meta']['config_hash'] = config_hash
        with open(new_file, 'w') as f:
            yaml.dump(new_config, f, default_flow_style=False, sort_keys=False)
        
        # Register in database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO versions 
            (version, created_at, config_hash, config_path, status, created_by)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (
            new_version,
            datetime.now().isoformat(),
            config_hash,
            str(new_file),
            'draft',
            'mirko'
        ))
        
        cursor.execute("""
            INSERT INTO version_history
            (from_version, to_version, change_type, changed_params, created_by)
            VALUES (?, ?, ?, ?, ?)
        """, (
            from_version,
            new_version,
            new_config['version_meta']['change_type'],
            json.dumps(changes),
            'mirko'
        ))
        
        conn.commit()
        conn.close()
        
        print(f"‚úÖ Created version v{new_version}")
        print(f"   File: {new_file}")
        print(f"   Hash: {config_hash}")
    
    def diff_versions(self, version1: str, version2: str):
        """Show differences between two versions."""
        v1_file = self.versions_dir / f"v{version1}.yaml"
        v2_file = self.versions_dir / f"v{version2}.yaml"
        
        if not v1_file.exists() or not v2_file.exists():
            print(f"‚ùå One or both versions not found")
            return
        
        with open(v1_file, 'r') as f:
            v1_config = yaml.safe_load(f)
        with open(v2_file, 'r') as f:
            v2_config = yaml.safe_load(f)
        
        v1_params = v1_config.get('parameters', {})
        v2_params = v2_config.get('parameters', {})
        
        print(f"\n‚ïê‚ïê‚ïê Comparing v{version1} ‚Üí v{version2} ‚ïê‚ïê‚ïê\n")
        
        all_keys = set(v1_params.keys()) | set(v2_params.keys())
        
        changes_found = False
        for key in sorted(all_keys):
            v1_val = v1_params.get(key)
            v2_val = v2_params.get(key)
            
            if v1_val != v2_val:
                changes_found = True
                print(f"  {key}:")
                print(f"    v{version1}: {v1_val}")
                print(f"    v{version2}: {v2_val}")
                print()
        
        if not changes_found:
            print("  No parameter changes")
    
    def _suggest_next_version(self, current: str) -> str:
        """Suggest next version number."""
        parts = current.split('.')
        if len(parts) == 2:
            major, minor = parts
            new_minor = int(minor) + 1
            if new_minor >= 100:
                return f"{int(major)+1}.00"
            return f"{major}.{new_minor:02d}"
        return f"{int(current)}.01"
    
    def _is_minor_update(self, old: str, new: str) -> bool:
        """Check if version change is minor increment."""
        old_parts = old.split('.')
        new_parts = new.split('.')
        if len(old_parts) == 2 and len(new_parts) == 2:
            return old_parts[0] == new_parts[0]
        return False
    
    def _calculate_hash(self, file_path: Path) -> str:
        """Calculate config file hash."""
        with open(file_path, 'r') as f:
            content = f.read()
        return hashlib.sha256(content.encode()).hexdigest()[:8]


def main():
    parser = argparse.ArgumentParser(description="Strategy Version Manager")
    parser.add_argument('command', choices=['list', 'show', 'create', 'diff', 'deploy'])
    parser.add_argument('strategy', help="Strategy name (e.g., inside_bar)")
    parser.add_argument('version', nargs='?', help="Version number (e.g., 1.00)")
    parser.add_argument('--from', dest='from_version', help="Parent version for create")
    parser.add_argument('--to', dest='to_stage', help="Deployment stage")
    parser.add_argument('--set', dest='params', action='append', help="Set parameter (key=value)")
    parser.add_argument('--notes', help="Version notes")
    parser.add_argument('version2', nargs='?', help="Second version for diff")
    
    args = parser.parse_args()
    
    mgr = StrategyVersionManager(args.strategy)
    
    if args.command == 'list':
        mgr.list_versions()
    
    elif args.command == 'show':
        if not args.version:
            print("‚ùå Version required")
            return
        mgr.show_version(args.version)
    
    elif args.command == 'create':
        if not args.from_version:
            print("‚ùå --from required")
            return
        
        params_to_change = {}
        if args.params:
            for param in args.params:
                key, value = param.split('=')
                # Try to parse as number or keep as string
                try:
                    value = float(value) if '.' in value else int(value)
                except ValueError:
                    pass
                params_to_change[key] = value
        
        mgr.create_version(
            args.from_version,
            args.version,
            params_to_change,
            args.notes or ""
        )
    
    elif args.command == 'diff':
        if not args.version or not args.version2:
            print("‚ùå Two versions required")
            return
        mgr.diff_versions(args.version, args.version2)
    
    elif args.command == 'deploy':
        print("Deploy command not yet implemented")


if __name__ == "__main__":
    main()
