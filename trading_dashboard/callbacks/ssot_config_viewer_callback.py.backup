"""Callback for editable SSOT strategy configuration in Backtests UI (UI-state only)."""

import logging
from dash import Input, Output, State, html, dcc, ALL, MATCH
from dash.exceptions import PreventUpdate
from trading_dashboard.config_store.strategy_config_store import StrategyConfigStore

logger = logging.getLogger(__name__)


def _create_input_for_param(key, value, section):
    """Create appropriate input component based on value type."""
    input_id = {"type": "ssot-param-input", "section": section, "key": key}
    
    if isinstance(value, bool):
        # Checkbox for boolean
        return html.Div([
            html.Label(key, style={"fontSize": "0.85em", "marginTop": "4px"}),
            dcc.Checklist(
                id=input_id,
                options=[{"label": "", "value": "true"}],
                value=["true"] if value else [],
                style={"marginBottom": "8px"},
            ),
        ])
    elif isinstance(value, int):
        # Number input for integers
        return html.Div([
            html.Label(key, style={"fontSize": "0.85em", "marginTop": "4px"}),
            dcc.Input(
                id=input_id,
                type="number",
                value=value,
                step=1,
                style={"width": "100%", "marginBottom": "8px"},
            ),
        ])
    elif isinstance(value, float):
        # Number input for floats
        return html.Div([
            html.Label(key, style={"fontSize": "0.85em", "marginTop": "4px"}),
            dcc.Input(
                id=input_id,
                type="number",
                value=value,
                step=0.1,
                style={"width": "100%", "marginBottom": "8px"},
            ),
        ])
    else:
        # Text input for strings and others
        return html.Div([
            html.Label(key, style={"fontSize": "0.85em", "marginTop": "4px"}),
            dcc.Input(
                id=input_id,
                type="text",
                value=str(value),
                style={"width": "100%", "marginBottom": "8px"},
            ),
        ])


def register_ssot_config_viewer_callback(app):
    """Register callbacks for editable SSOT config viewer."""
    
    @app.callback(
        Output("ssot-strategy-id", "options"),
        Input("ssot-strategy-id", "id"),  # Trigger on component mount
    )
    def populate_strategy_dropdown(_):
        """Populate strategy dropdown from registry."""
        from src.strategies.config.registry import config_manager_registry
        
        strategies = config_manager_registry.list_strategies()
        
        if not strategies:
            return []
        
        return [{"label": sid, "value": sid} for sid in sorted(strategies)]
    
    @app.callback(
        Output("ssot-version", "options"),
        Input("ssot-strategy-id", "value"),
    )
    def populate_version_dropdown(strategy_id):
        """Populate version dropdown based on selected strategy."""
        if not strategy_id:
            return []
        
        try:
            from src.strategies.config.registry import config_manager_registry
            
            manager = config_manager_registry.get_manager(strategy_id)
            if not manager:
                return []
            
            # Load the YAML file to get available versions
            config = manager.load()
            versions = list(config.get("versions", {}).keys())
            
            if not versions:
                return []
            
            # Sort versions (newest first for common semver)
            sorted_versions = sorted(versions, reverse=True)
            
            return [{"label": v, "value": v} for v in sorted_versions]
            
        except Exception as e:
            logger.warning(f"Failed to load versions for {strategy_id}: {e}")
            return []
    
    @app.callback(
        [
            Output("ssot-load-status", "children"),
            Output("ssot-loaded-defaults", "data"),
            Output("ssot-editable-fields", "children"),
        ],
        [
            Input("ssot-load-button", "n_clicks"),
            Input("ssot-reset-button", "n_clicks"),
        ],
        [
            State("ssot-strategy-id", "value"),
            State("ssot-version", "value"),
            State("ssot-loaded-defaults", "data"),
        ],
        prevent_initial_call=True
    )
    def load_or_reset_config(load_clicks, reset_clicks, strategy_id, version, loaded_defaults):
        """Load config from SSOT or reset to loaded defaults."""
        from dash import callback_context
        
        if not callback_context.triggered:
            raise PreventUpdate
        
        trigger_id = callback_context.triggered[0]["prop_id"].split(".")[0]
        
        # Reset button: restore from loaded_defaults
        if trigger_id == "ssot-reset-button":
            if not loaded_defaults:
                raise PreventUpdate
            
            logger.info(f"actions: ui_config_reset strategy_id={loaded_defaults.get('strategy_id')} version={loaded_defaults.get('version')}")
            
            # Recreate fields from loaded defaults
            fields = _create_editable_fields(loaded_defaults)
            
            status = html.Div(
                [
                    html.Span("üîÑ ", style={"color": "#51cf66"}),
                    html.Span(
                        "Reset to loaded defaults",
                        style={"color": "#51cf66", "fontSize": "0.85em"}
                    ),
                ],
            )
            
            return status, loaded_defaults, fields
        
        # Load button: fetch from SSOT
        if not strategy_id or not version:
            status = html.Div(
                "‚ö†Ô∏è Please enter both strategy_id and version",
                style={"color": "#ff6b6b", "fontSize": "0.85em"}
            )
            return status, None, []
        
        try:
            # Load from SSOT
            defaults = StrategyConfigStore.get_defaults(strategy_id.strip(), version.strip())
            
            # Log action
            core_params = defaults.get("core", {})
            tunable_params = defaults.get("tunable", {})
            logger.info(
                f"actions: ui_config_loaded strategy_id={strategy_id} "
                f"version={version} core_keys={len(core_params)} tunable_keys={len(tunable_params)}"
            )
            
            # Create editable fields
            fields = _create_editable_fields(defaults)
            
            # Success status
            status = html.Div(
                [
                    html.Span("‚úÖ ", style={"color": "#51cf66"}),
                    html.Span(
                        f"Loaded {strategy_id} v{version} (editable, UI-state only)",
                        style={"color": "#51cf66", "fontSize": "0.85em"}
                    ),
                ],
                style={"marginTop": "4px"}
            )
            
            return status, defaults, fields
            
        except FileNotFoundError as e:
            logger.warning(f"actions: ui_load_config_failed exc=FileNotFoundError msg={str(e)}")
            status = html.Div(
                [
                    html.Span("‚ùå ", style={"color": "#ff6b6b"}),
                    html.Span(f"File not found: {str(e)}", style={"color": "#ff6b6b", "fontSize": "0.85em"}),
                ],
            )
            return status, None, []
            
        except ValueError as e:
            logger.warning(f"actions: ui_load_config_failed exc=ValueError msg={str(e)}")
            status = html.Div(
                [
                    html.Span("‚ùå ", style={"color": "#ff6b6b"}),
                    html.Span(f"Validation error: {str(e)}", style={"color": "#ff6b6b", "fontSize": "0.85em"}),
                ],
            )
            return status, None, []
            
        except Exception as e:
            logger.error(f"actions: ui_load_config_failed exc={type(e).__name__} msg={str(e)}")
            status = html.Div(
                [
                    html.Span("‚ùå ", style={"color": "#ff6b6b"}),
                    html.Span(f"Error: {type(e).__name__}: {str(e)}", style={"color": "#ff6b6b", "fontSize": "0.85em"}),
                ],
            )
            return status, None, []


def _create_editable_fields(defaults):
    """Create editable input fields from defaults dict."""
    fields = []
    
    core_params = defaults.get("core", {})
    tunable_params = defaults.get("tunable", {})
    
    # Core parameters section
    if core_params:
        fields.append(
            html.Div([
                html.Strong(
                    "Core Parameters:",
                    style={"color": "#51cf66", "marginTop": "12px", "marginBottom": "8px", "display": "block"}
                ),
                html.Div(
                    [_create_input_for_param(key, value, "core") for key, value in core_params.items()],
                    style={
                        "padding": "8px",
                        "backgroundColor": "rgba(255,255,255,0.02)",
                        "borderRadius": "4px",
                    }
                ),
            ])
        )
    
    # Tunable parameters section
    if tunable_params:
        fields.append(
            html.Div([
                html.Strong(
                    "Tunable Parameters:",
                    style={"color": "#51cf66", "marginTop": "12px", "marginBottom": "8px", "display": "block"}
                ),
                html.Div(
                    [_create_input_for_param(key, value, "tunable") for key, value in tunable_params.items()],
                    style={
                        "padding": "8px",
                        "backgroundColor": "rgba(255,255,255,0.02)",
                        "borderRadius": "4px",
                    }
                ),
            ])
        )
    
    return fields

    @app.callback(
        Output("ssot-save-version", "disabled"),
        [
            Input("ssot-loaded-defaults", "data"),
            Input("ssot-new-version", "value"),
        ]
    )
    def update_save_button_state(loaded_defaults, new_version):
        """Enable save button only when conditions are met."""
        if not loaded_defaults:
            return True  # Disabled
        if not new_version or not new_version.strip():
            return True  # Disabled
        return False  # Enabled

    @app.callback(
        [
            Output("ssot-save-status", "children"),
            Output("ssot-version", "value"),
            Output("ssot-version", "options", allow_duplicate=True),
            Output("ssot-loaded-defaults", "data", allow_duplicate=True),
            Output("ssot-editable-fields", "children", allow_duplicate=True),
        ],
        [
            Input("ssot-save-version", "n_clicks"),
        ],
        [
            State("ssot-strategy-id", "value"),
            State("ssot-version", "value"),  # Base version
            State("ssot-new-version", "value"),
            State("ssot-loaded-defaults", "data"),
            State({"type": "ssot-param-input", "section": ALL, "key": ALL}, "value"),
            State({"type": "ssot-param-input", "section": ALL, "key": ALL}, "id"),
        ],
        prevent_initial_call=True
    )
    def save_as_new_version(
        n_clicks, strategy_id, base_version, new_version,
        loaded_defaults, edited_values, edited_ids
    ):
        """Save edited parameters as new version + reload from YAML."""
        from dash import no_update
        
        if not n_clicks:
            raise PreventUpdate
        
        # 1. Validate preconditions
        if not loaded_defaults:
            status = html.Div("‚ùå Load config first", style={"color": "#ff6b6b", "fontSize": "0.85em"})
            return status, no_update, no_update, no_update, no_update
        
        new_version = new_version.strip() if new_version else ""
        if not new_version:
            status = html.Div("‚ùå Enter new version", style={"color": "#ff6b6b", "fontSize": "0.85em"})
            return status, no_update, no_update, no_update, no_update
        
        if new_version == base_version:
            status = html.Div(
                f"‚ùå New version must differ from base ({base_version})",
                style={"color": "#ff6b6b", "fontSize": "0.85em"}
            )
            return status, no_update, no_update, no_update, no_update
        
        # 2. Build overrides (diff-only)
        core_overrides, tunable_overrides = _compute_overrides(
            loaded_defaults, edited_values, edited_ids
        )
        
        # 3. Call write path
        try:
            StrategyConfigStore.save_new_version(
                strategy_id=strategy_id,
                base_version=base_version,
                new_version=new_version,
                core_overrides=core_overrides,
                tunable_overrides=tunable_overrides
            )
            
            logger.info(
                f"actions: ui_config_version_saved strategy_id={strategy_id} "
                f"base={base_version} new={new_version} "
                f"core_overrides={len(core_overrides)} tunable_overrides={len(tunable_overrides)}"
            )
            
        except ValueError as e:
            logger.warning(f"actions: ui_save_version_failed exc=ValueError msg={str(e)}")
            status = html.Div(
                [html.Span("‚ùå ", style={"color": "#ff6b6b"}), html.Span(str(e), style={"color": "#ff6b6b", "fontSize": "0.85em"})],
            )
            return status, no_update, no_update, no_update, no_update
        except Exception as e:
            logger.error(f"actions: ui_save_version_failed exc={type(e).__name__} msg={str(e)}")
            status = html.Div(
                [html.Span("‚ùå ", style={"color": "#ff6b6b"}), html.Span(f"Save failed: {str(e)}", style={"color": "#ff6b6b", "fontSize": "0.85em"})],
            )
            return status, no_update, no_update, no_update, no_update
        
        # 4. Reload from YAML (live read, no cache)
        try:
            defaults_new = StrategyConfigStore.get_defaults(strategy_id, new_version)
            
            logger.info(f"actions: ui_config_reloaded strategy_id={strategy_id} version={new_version}")
            
        except Exception as e:
            logger.error(f"actions: ui_reload_failed exc={type(e).__name__} msg={str(e)}")
            status = html.Div(
                [html.Span("‚ö†Ô∏è ", style={"color": "#ff9800"}), html.Span(f"Saved but reload failed: {str(e)}", style={"color": "#ff9800", "fontSize": "0.85em"})],
            )
            return status, no_update, no_update, no_update, no_update
        
        # 5. Update version dropdown options (live from YAML)
        version_options = _get_version_options(strategy_id)
        
        # 6. Recreate editable fields from new defaults
        fields = _create_editable_fields(defaults_new)
        
        # 7. Success status
        status = html.Div(
            [
                html.Span("‚úÖ ", style={"color": "#51cf66"}),
                html.Span(f"Saved as v{new_version} and reloaded", style={"color": "#51cf66", "fontSize": "0.85em"}),
            ],
        )
        
        return status, new_version, version_options, defaults_new, fields


def _compute_overrides(loaded_defaults, edited_values, edited_ids):
    """Compute diff-only overrides from UI edits."""
    core_overrides = {}
    tunable_overrides = {}
    
    for value, id_dict in zip(edited_values, edited_ids):
        section = id_dict["section"]
        key = id_dict["key"]
        
        # Get original value from loaded defaults
        original = loaded_defaults[section][key]
        
        # Type conversion based on original
        if isinstance(original, bool):
            # Checkbox: list ["true"] or []
            new_value = (value == ["true"]) if isinstance(value, list) else bool(value)
        elif isinstance(original, int):
            new_value = int(value) if value else 0
        elif isinstance(original, float):
            new_value = float(value) if value else 0.0
        else:
            new_value = str(value)
        
        # Only include if changed
        if new_value != original:
            if section == "core":
                core_overrides[key] = new_value
            else:
                tunable_overrides[key] = new_value
    
    return core_overrides, tunable_overrides


def _get_version_options(strategy_id):
    """Get version options from YAML (live read)."""
    try:
        from src.strategies.config.registry import config_manager_registry
        manager = config_manager_registry.get_manager(strategy_id)
        if not manager:
            return []
        
        config = manager.load()
        versions = list(config.get("versions", {}).keys())
        sorted_versions = sorted(versions, reverse=True)
        
        return [{"label": v, "value": v} for v in sorted_versions]
    except Exception:
        return []
