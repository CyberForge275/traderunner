====================================================================
FILE: src/strategies/inside_bar/signal_frame_builder.py
TS:   2026-01-24 21:50
OLD:  fa519c768cc435e756035f7e2f4560d3b6254cf5
HEAD: f94c931ee5539d331a83092b2e7ef56d7a2cc9cc
====================================================================

------------------------------
OLD COMMIT META
------------------------------
OLD fa519c7 2026-01-16 14:31:51 +0100 fix(pipeline): restore missing files for decoupled architecture and fix integration tests

------------------------------
HEAD COMMIT META
------------------------------
HEAD f94c931 2026-01-30 16:19:49 +0100 fix(parity): align valid_from/to to golden window policies

------------------------------
COMMITS SINCE OLD (for FILE)
------------------------------
018f772 chore(insidebar): remove builder; wire registry to core SSOT

------------------------------
DIFF STAT
------------------------------
 src/strategies/inside_bar/signal_frame_builder.py | 162 ----------------------
 1 file changed, 162 deletions(-)

------------------------------
DIFF FULL
------------------------------
diff --git a/src/strategies/inside_bar/signal_frame_builder.py b/src/strategies/inside_bar/signal_frame_builder.py
deleted file mode 100644
index 8b343d2..0000000
--- a/src/strategies/inside_bar/signal_frame_builder.py
+++ /dev/null
@@ -1,162 +0,0 @@
-"""InsideBar signal frame builder (Strategy-owned logic)."""
-
-from __future__ import annotations
-
-import logging
-from typing import Dict
-from .config import SessionFilter
-
-import pandas as pd
-import numpy as np
-
-logger = logging.getLogger(__name__)
-
-
-def extend_insidebar_signal_frame(
-    bars: pd.DataFrame,
-    schema,
-    strategy_id: str,
-    strategy_tag: str,
-    params: Dict,
-) -> pd.DataFrame:
-    """Deterministically enrich bars with inside-bar signal columns.
-
-    This matches the legacy InsideBarCore logic for signal parity.
-    """
-    if bars.empty:
-        raise ValueError("bars empty; cannot build signal frame")
-
-    df = bars.copy()
-    df = df.sort_values("timestamp").reset_index(drop=True)
-
-    # 1. Proper ATR Calculation (Legacy SMA of True Range)
-    atr_period = int(params.get("atr_period", 15))
-    df["prev_close"] = df["close"].shift(1)
-    df["tr1"] = df["high"] - df["low"]
-    df["tr2"] = (df["high"] - df["prev_close"]).abs()
-    df["tr3"] = (df["low"] - df["prev_close"]).abs()
-    df["true_range"] = df[["tr1", "tr2", "tr3"]].max(axis=1)
-    df["atr"] = df["true_range"].rolling(window=atr_period, min_periods=atr_period).mean()
-    # No bfill() to match legacy "cold start" behavior
-    df["atr"] = df["atr"].fillna(0.0)
-
-    # 2. Inside Bar Identification & Filtering
-    df["p_high"] = df["high"].shift(1)
-    df["p_low"] = df["low"].shift(1)
-    df["p_range"] = df["p_high"] - df["p_low"]
-    
-    ib_mode = params.get("inside_bar_mode", "inclusive")
-    if ib_mode == "strict":
-        ib_mask = (df["high"] < df["p_high"]) & (df["low"] > df["p_low"])
-    else:
-        ib_mask = (df["high"] <= df["p_high"]) & (df["low"] >= df["p_low"])
-    
-    # Mother Bar Size Filter
-    min_mother_size = float(params.get("min_mother_bar_size", 0.5))
-    size_ok = df["p_range"] >= (min_mother_size * df["atr"])
-    
-    # Core legacy behavior: Inside Bar must be valid AND mother bar size must be OK
-    df["is_ib_candidate"] = ib_mask & size_ok.fillna(False) & df["p_high"].notna()
-
-    # Pre-materialize all schema columns
-    for col in schema.all_columns():
-        if col.name not in df.columns:
-            if col.dtype == "bool":
-                df[col.name] = False
-            else:
-                df[col.name] = pd.NA
-
-    # 3. Session-Aware State Machine (Legacy Netting & Breakout Logic)
-    session_windows = params.get("session_filter", [])
-    session_tz = params.get("session_timezone", "America/New_York")
-    max_age = int(params.get("max_pattern_age_candles", 12))
-
-    if session_windows:
-        sf = SessionFilter.from_strings(session_windows)
-        # state: {armed: bool, levels: dict, done: bool, age: int}
-        session_states = {} 
-        
-        final_sides = [None] * len(df)
-        exit_timestamps = [pd.NA] * len(df)
-        exit_reasons = [None] * len(df)
-        entry_prices = [pd.NA] * len(df)
-        
-        for idx, row in df.iterrows():
-            ts = pd.to_datetime(row["timestamp"])
-            ts_local = ts.tz_convert(session_tz)
-            
-            s_idx = sf.get_session_index(ts, session_tz)
-            if s_idx is None:
-                continue
-                
-            s_key = (ts_local.date(), s_idx)
-            if s_key not in session_states:
-                session_states[s_key] = {"armed": False, "levels": None, "done": False, "age": 0}
-            
-            state = session_states[s_key]
-            
-            if state["done"]:
-                continue
-
-            # Case A: Not armed yet, look for first valid Inside Bar
-            if not state["armed"]:
-                # Legacy Parity: Mother bar MUST be in same session window
-                prev_s_idx = sf.get_session_index(pd.to_datetime(df.iloc[idx-1]["timestamp"]), session_tz)
-                if prev_s_idx != s_idx:
-                    continue
-
-                if row["is_ib_candidate"]:
-                    state["armed"] = True
-                    state["levels"] = {"high": row["p_high"], "low": row["p_low"]}
-                    state["age"] = 0
-                    # Legacy logic: skip breakout check on the arming bar
-                    continue
-            
-            # Case B: Armed, watch for breakout
-            if state["armed"]:
-                state["age"] += 1
-                levels = state["levels"]
-                
-                side = None
-                if row["close"] > levels["high"]:
-                    side = "BUY"
-                elif row["close"] < levels["low"]:
-                    side = "SELL"
-                
-                if side:
-                    final_sides[idx] = side
-                    state["done"] = True
-                    # Calculate EOD Exit
-                    s_end = sf.get_session_end(ts, session_tz)
-                    exit_timestamps[idx] = s_end
-                    exit_reasons[idx] = "session_end"
-                    
-                    # Legacy Parity: entry price is the trigger level
-                    if side == "BUY":
-                        entry_prices[idx] = state["levels"]["high"]
-                    else:
-                        entry_prices[idx] = state["levels"]["low"]
-                else:
-                    # Check age limit
-                    if state["age"] >= max_age:
-                        state["armed"] = False # Disarm
-        
-        df["signal_side"] = final_sides
-        df["exit_ts"] = exit_timestamps
-        df["exit_reason"] = exit_reasons
-        df["entry_price"] = entry_prices
-
-    # Final enrichment
-    df["signal_reason"] = df["signal_side"].apply(lambda s: "inside_bar" if s else None)
-    df["stop_price"] = pd.NA
-    df["take_profit_price"] = pd.NA
-    df["template_id"] = [f"ib_tpl_{i}" for i in range(len(df))]
-
-    # Metadata
-    df["symbol"] = params.get("symbol", "UNKNOWN")
-    df["timeframe"] = params.get("timeframe", "")
-    df["strategy_id"] = strategy_id
-    df["strategy_version"] = params.get("strategy_version", "")
-    df["strategy_tag"] = strategy_tag
-
-    return df

